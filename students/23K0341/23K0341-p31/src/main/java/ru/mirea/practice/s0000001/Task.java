package ru.mirea.practice.s0000001;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;

/**
 * Во входном текстовом файле PROCS.TXT содержится таблица со сведениями о современных микропроцессорах.
 * Ограничения на входные данные:
 * Каждая запись таблицы занимает в файле одну строку следующего вида:
 * ключ записи, название процессора, тактовая частота, размер кеш-памяти, частота системной шины,
 * результат теста SPECint, результат теста SPECfp
 * ключ записи – натуральное число < maxint;
 * название процессора – строка длиной не более 30 символов (название не содержит запятых!);
 * тактовая частота (в ГГц) – положительное вещественное число, представимое real;
 * размер кеш-памяти (в Кб) – неотрицательное целое < maxint;
 * частота системной шины (в ГГц) – положительное вещественное число, представимое real;
 * результаты тестов – натуральные числа < maxint. Данные в файле записаны без ошибок.
 * Программа считывает содержимое файла и строит 2-3 дерево, в листьях которого содержатся записи таблицы. После
 * этого она ждет от пользователя команду и выполняет ее.
 * Команды (буквы в командах латинские малые или заглавные):
 * L – вывести на экран вершины дерева, как определено вариантом задания. Для листовой вершины выводится ключ.
 * Для остальных вершин выводится один ключ и символ '–' (если у вершины 2 сына), либо оба ключа (если у вершины 3
 * сына).
 * D n – (где n – ключ записи) удалить из дерева запись с ключом n, если такой записи нет, предупредить об этом
 * пользователя;
 * A n – (где n – ключ записи) добавить в дерево запись с ключом n, если запись с таким ключом уже есть, предупредить
 * об этом пользователя. Содержимое полей записи программа запрашивает у пользователя.
 * S – записать в файл PROCS.TXT все записи из дерева.
 * E – выйти из программы.
 * После выполнения одной команды ожидается следующая, и так до тех пор, пока не будет выполнена команда E
 * (выход).
 * ВАРИАНТЫ:
 * В каком порядке печатать вершины ( цифра варианта ):
 * 1
 * Печатать вершины по уровням слева направо, начиная с нижнего уровня.
 * 2
 * Печатать вершины по уровням слева направо, начиная с верхнего уровня.
 * 3
 * Порядок печати: левое поддерево, среднее поддерево, правое поддерево (если есть), а затем корень. Правило
 * печати применяется рекурсивно ко всем поддеревьям в дереве.
 * 4
 * Порядок печати: корень, левое поддерево, среднее поддерево, правое поддерево (если есть). Правило печати
 * применяется рекурсивно ко всем поддеревьям в дереве.
 * 5
 * См. вариант 3) + для каждой вершины выводится дополнительная информация – номер уровня дерева, на котором
 * расположена вершина.
 * 6
 * См. вариант 4) + для каждой вершины выводится дополнительная информация – номер уровня дерева, на котором
 * расположена вершина.
 * Ограничения на реализацию обхода дерева при печати (буква варианта):
 * Р) можно использовать рекурсивные вызовы процедур и/или функций;
 * С) рекурсивные вызовы запрещены, использовать стек.
 * Пример входного файла и дерева, построенного по нему:
 * PROCS.TXT
 * 2, Intel Pentium 4, 2.0, 256, 0.400, 664, 734
 * 5, Intel Itanium, 0.800, 96, 0.266, 365, 701
 * 6, AMD Athlon XP, 1.6, 256, 0.266, 701, 634
 * 1, IBM Power 4, 1.3, 16384, 0.400, 814, 1169
 * (Данные взяты с www.parallel.ru)
 * Распечатка дерева по варианту 1:
 * 1, 2, 5, 6,
 * 2 –, 6 –,
 * 5 –
 * Распечатка дерева по варианту 3:
 * 1, 2, 2 –, 5, 6, 6 –, 5 –
 * Распечатка дерева по варианту 6:
 * 5 – (уровень 1), 2 – (уровень 2), 1 (уровень 3), 2 (уровень 3), 6 – (уровень 2), 5 (уровень 3), 6 (уровень 3)
 */

public abstract class Task {
    static class Node {
        Data data;
        Node left;
        Node right;

        Node(Data data) {
            this.data = data;
            left = null;
            right = null;
        }

        @Override
        public String toString() {
            return "Node { " + data + " }";
        }
    }

    static void insert(Node to, Node node) {
        if (to.data.key < node.data.key && to.right == null) {
            to.right = node;
        } else if (to.data.key < node.data.key) {
            insert(to.right, node);
        } else if (to.left == null) {
            to.left = node;
        } else {
            insert(to.left, node);
        }
    }

    static class Data {
        int key;
        String[] data;

        Data(String[] from) {
            key = Integer.parseInt(from[0]);
            data = new String[from.length - 1];
            System.arraycopy(from, 1, data, 0, from.length - 1);
        }

        @Override
        public String toString() {
            return "{ key=" + key + "; data=" + Arrays.toString(data) + " }";
        }
    }

    static void print(Node node) {
        if (node != null) {
            print(node.right);
            print(node.left);
            System.out.print(node.data.key);
            System.out.print(" ");
        }
    }

    public static void main(String[] args) {
        StringBuilder sb = null;
        try (BufferedReader br = new BufferedReader(new FileReader("file.txt"))) {
            sb = new StringBuilder();
            String line = br.readLine();
            while (line != null) {
                sb.append(line).append("\n");
                line = br.readLine();
            }
            System.out.println(sb);
        } catch (IOException e) {
            System.out.println(e.getMessage());
        }

        if (sb == null) {
            return;
        }

        Node tree = null;
        for (String line : sb.toString().split("\n")) {
            Node node = new Node(new Data(line.split(", ")));

            if (tree == null) {
                tree = node;
            } else {
                insert(tree, node);
            }
        }

        print(tree);
    }
}
